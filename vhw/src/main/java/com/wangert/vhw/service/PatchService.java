package com.wangert.vhw.service;


import com.wangert.vhw.contracts.geth.PatchStorageContract;
import com.wangert.vhw.contracts.geth.UserStorageContract;
import com.wangert.vhw.contracts.geth.VulnerabilityStorageContract;
import com.wangert.vhw.dao.IpfsStorage;
import com.wangert.vhw.utils.FileUtil;
import com.wangert.vhw.utils.PropertyUtil;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 *
 * 补丁相关服务类
 * @Author：Wangert
 *
 */

@Service
public class PatchService {

    final String patchPath = "src/main/resources/files/patches/";
    final String ipfsDownloadPath = "src/main/resources/files/ipfsDownload/";
    final String patchListPath = "src/main/resources/dataCache/patchList.txt";
    //主页数据缓存路径
    final String homePageDataPath = "src/main/resources/dataCache/homePageData.properties";
    //主页数据缓存路径
    final String homePageDataPatchPath = "src/main/resources/dataCache/homePageDataPatch.properties";
    //记录每个用户所拥有的补丁缓存文件的前缀
    final String userPatchesPrefix = "src/main/resources/dataCache/userPatches/";
    //记录漏洞对应的补丁缓存文件的前缀
    final String patchesOfVulnerabilityPrefix = "src/main/resources/dataCache/patchesOfVulnerability/";
    //记录评估行为
    final String patchAssessmentPath = "src/main/resources/dataCache/dashboardData/patchAssessment.txt";

    //声明补丁合约类
    PatchStorageContract patchStorageContract = PatchStorageContract.getInstance();
    //声明漏洞合约类
    VulnerabilityStorageContract vulnerabilityStorageContract = VulnerabilityStorageContract.getInstance();
    //声明用户合约类
    UserStorageContract userStorageContract = UserStorageContract.getInstance();

    public PatchService() {}

    //上传漏洞到IPFS并且将Hash记录到区块链
    public boolean publishPatch(String username, String vulnerabilityHash, String patchName, String description, String patchStorageName) {

        //声明IPFS文件存储工具对象
        IpfsStorage ipfsStorage = new IpfsStorage();

        //记录返回ipfsHash
        String ipfsHash;

        try {
            //将对应文件上传至ipfs
            ipfsHash = ipfsStorage.ipfsUpload(patchPath + patchStorageName);

            Date date = new Date();
            SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            String currentDate = dateFormat.format(date);
            //调用合约添加补丁
            boolean addFlag = patchStorageContract.addPatch(ipfsHash, patchName, username, currentDate, vulnerabilityHash);

            //添加失败
            if (addFlag == false) {

                System.out.println("Patch add failed!");
                return false;

            }

            //======================增加漏洞和补丁的对应关系=================
            addFlag = vulnerabilityStorageContract.addPatch(vulnerabilityHash, ipfsHash);

            //为漏洞增加补丁失败
            if (addFlag == false) {

                System.out.println("Vulnerability and Patch connect failed!");
                return false;

            }

            //修改用户数据信息
            addFlag = userStorageContract.addReleasePatch(username, ipfsHash);
            if (addFlag == false) {

                System.out.println("Update user information failed!");
                return false;

            }

            //文件操作工具对象
            FileUtil fileUtil = new FileUtil();
            //将新补丁Hash写入到缓存文件中
            fileUtil.fileWrite(ipfsHash, patchListPath);
            fileUtil.fileWrite(ipfsHash, userPatchesPrefix + username + ".txt");
            fileUtil.fileWrite(ipfsHash, patchesOfVulnerabilityPrefix + vulnerabilityHash + ".txt");

            //主页数据缓存文件操作对象
            PropertyUtil propertyUtil = new PropertyUtil(homePageDataPatchPath);

            //补丁名称@@@发布者@@@对应的漏洞Hash发布时间@@@补丁描述@@@补丁star数@@@补丁评分@@@评估人数
            String newData = patchName + "@@@" + username + "@@@" + vulnerabilityHash + "@@@" + currentDate + "@@@"  + description + "@@@0@@@0@@@0";
            //写入到主页数据缓存文件中
            propertyUtil.appendData(ipfsHash, newData, ipfsHash + "=补丁名称@@@发布者@@@对应的漏洞Hash发布时间@@@补丁描述@@@补丁star数@@@补丁评分@@@评估人数");


        }catch (Exception e) {
            e.printStackTrace();
        }


        return true;

    }


    public void downloadPatchByIpfsHash(String ipfsHash) {
        //声明IPFS文件存储工具对象
        IpfsStorage ipfsStorage = new IpfsStorage();

        try {

            //从ipfs上下载漏洞
            ipfsStorage.ipfsDownloadByHash(ipfsDownloadPath + ipfsHash + ".zip", ipfsHash);

        }catch (IOException e) {
            e.printStackTrace();
        }

    }

    //评估补丁
    public boolean assessPatchByIpfsHash(String assessor, String ipfsHash, int score) {
//        //定义用户合约操作对象
//        UserStorageContract userStorageContract = new UserStorageContract();
//        //定义补丁合约操作对象
//        PatchStorageContract patchStorageContract = new PatchStorageContract();

        Date date = new Date();
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String currentDate = dateFormat.format(date);

        //更新后的总评分
        int newScore;

        //缓存文件数据操作对象
        PropertyUtil propertyUtil1 = new PropertyUtil(homePageDataPatchPath);
        PropertyUtil propertyUtil2 = new PropertyUtil(homePageDataPath);
        try {

            //从缓存文件中获取数据
            //补丁名称@@@发布者@@@对应的漏洞Hash发布时间@@@补丁描述@@@补丁star数@@@补丁评分@@@评估人数
            String s = propertyUtil1.getData(ipfsHash);
            String c = propertyUtil2.getData(assessor + "Contribution");
            String[] arrStr = s.split("@@@");
            int oldScore = Integer.valueOf(arrStr[6]).intValue();
            int oldNumberOfUser = Integer.valueOf(arrStr[7]).intValue();

            //记录该assessor评估此补丁
            if (userStorageContract.addAssessPatchScore(assessor, ipfsHash, score) == false) {
                System.out.println(assessor+"已经评估过补丁" + ipfsHash);
                return false;
            }
            //修改assessor的贡献值
            userStorageContract.addTotalAndResidualContribution(assessor, 5);
            //更新用户贡献值
            String[] cArrStr =  c.split("@@@");
            int newRContribution = Integer.valueOf(cArrStr[0]).intValue() + 5;
            int newTContribution = Integer.valueOf(cArrStr[1]).intValue() + 5;
            String newContribution = newRContribution + "@@@" + newTContribution;

            int oldTContribution = Integer.valueOf(cArrStr[1]);

            //计算评估后的新总分
            //加权后评分
            newScore = (int)(oldScore * oldNumberOfUser + score * ((float)(oldTContribution + 5)/(55 + oldTContribution)) * 2) / (oldNumberOfUser + 1);

            System.out.println("newScore:" + newScore);
            //此处合约有误
            patchStorageContract.addPatchTotalScore(ipfsHash, newScore);

            //补丁名称@@@发布者@@@对应的漏洞Hash发布时间@@@补丁描述@@@补丁star数@@@补丁评分@@@评估人数
            //新评估人数
            int newNumberOfUser = oldNumberOfUser + 1;
            String newPatchData = arrStr[0] + "@@@" + arrStr[1] + "@@@" + arrStr[2] + "@@@" + arrStr[3] + "@@@" + arrStr[4] + "@@@" + arrStr[5] + "@@@" + newScore + "@@@" + newNumberOfUser;

            propertyUtil2.updateData(assessor + "Contribution", newContribution, "update");
            propertyUtil1.updateData(ipfsHash, newPatchData, "update");

            FileUtil fileUtil = new FileUtil();
            String assessRecord = currentDate + "@@@" + assessor + "@@@" + ipfsHash + "@@@" + score;
            fileUtil.fileWrite(assessRecord, patchAssessmentPath);


        }catch (Exception e) {
            e.printStackTrace();
        }



        return true;
    }





}
